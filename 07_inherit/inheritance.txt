상속
  1. 다른 클래스의 기능(메소드)을 물려 받아서 사용할 수 있는 기능이다.
  2. 다음 관계가 있는 클래스들을 상속 관계로 만들 수 있다.
    1) is a  관계 : ~은 ~이다.
    2) has a 관계 : ~은 ~을 가지고 있다.
 
 
부모 클래스
  1. 자식 클래스에게 기능(메소드)를 제공한다.
  2. 슈퍼 클래스(super)라고 한다. (위)

자식 클래스
  1. 부모 클래스의 기능(메소드)을 자신의 것처럼 사용할 수 있다.
  2. 서브 클래스(sub)라고 한다. (아래)


is a 관계
  1. 상속 관계로 만들 수 있는 대표적인 관계이다.
  2. 예시
    Student is a Person. (학생은 사람이다.)
  3. 개념
    자식클래스 is a 부모클래스


상속 관계 도식
   ┌--------------┐
   │    Person    │ 슈퍼 클래스
   │--------------│
   │     eat()    │
   │    sleep()   │
   └--------------┘
           ▲
           │
   ┌--------------┐
   │   Developer  │ 서브 클래스
   │--------------│
   │   develop()  │
   └--------------┘
           ▲
           │
   ┌--------------┐
   │ WebDeveloper │ 서브 클래스
   │--------------│
   │   deploy()   │
   └--------------┘
 
 
has a 관계
  1. 어떤 클래스가 다른 클래스의 기능을 포함하는 경우 사용할 수 있다.
  2. 상속으로 해결하는 것 보다는 포함 관계로 해결하는 것이 나을 수 있다.
  3. 예시
    Tv has a Remocon. (Tv는 Remocon을 가지고 있다.)
  4. 개념
    자식클래스 has a 부모클래스


상속 관계의 생성자
  1. 자식 클래스를 생성할 땐 "반드시" 부모 클래스를 "먼저" 생성해야 한다.
    (서브 클래스를 생성할 땐 "반드시" 슈퍼 클래스를 "먼저" 생성해야 한다.)
  2. 서브 클래스의 생성자가 호출될 때는 "반드시" 슈퍼 클래스의 생성자를 "먼저" 호출해야 한다.
  3. 만약 서브 클래스의 생성자에서 슈퍼 클래스의 생성자를 호출하지 않으면 Java에 의해서 슈퍼 클래스의 "디폴트 생성자"가 호출된다.
  4. 서브 클래스의 생성자에서 슈퍼 클래스의 생성자를 호출하는 방법은 super() 이다.

 
메소드 오버라이드(method override)
  1. 슈퍼 클래스의 메소드를 서브 클래스가 다시 만드는 것을 말한다. (메소드 덮어쓰기)
  2. 오버라이드 하는 메소드는 @Override Annotation을 추가하는 것이 좋다. (권장이지만 필수로 하자.)
  3. 반드시 슈퍼 클래스의 메소드와 동일한 모습으로 오버라이드 해야 한다.
  4. 정확히는 반환타입/메소드명/매개변수 이렇게 3가지가 일치해야 한다.
 
 
업캐스팅(upcasting)
  1. 서브 클래스 객체를 슈퍼 클래스 타입으로 저장할 수 있다.
  2. 강제로 캐스팅(형변환)할 필요가 없다. 자동으로 변환된다.
  3. 목적
    1) 슈퍼 클래스 타입으로 모든 서브 클래스 객체를 저장할 수 있다.
    2) 서로 다른 타입의 객체를 하나의 타입으로 관리할 수 있다.
  4. 주의할 점
    1) 슈퍼 클래스 타입으로 저장하기 때문에 슈퍼 클래스의 메소드만 호출할 수 있다.
    2) 이 문제를 해결하기 위해서 메소드 오버라이드(method override)를 이용할 수 있다.


java.lang.Object 클래스
  1. 모든 클래스의 최상위 슈퍼 클래스이다.
  2. 별도의 슈퍼 클래스를 명시하지 않은 클래스들은(extends가 없는 클래스) 모두 Object 클래스의 서브 클래스이다.
  3. 모든 것을 저장할 수 있는 만능 참조 타입이다.
  4. Object 타입으로 저장하면 Object 클래스의 메소드만 호출할 수 있다. 이를 해결하기 위해서는 "반드시" 캐스팅을 해야 한다.

  ┌--------------┐
  │  Object      │ 슈퍼 클래스
  │--------------│
  │  equals()    │ 두 객체의 참조값을 비교해서 같으면 true, 아니면 false 반환
  │  getClass()  │ 어떤 클래스인지 반환
  │  hashCode()  │ int 타입의 해시코드값, Object 클래스는 객체의 참조값을 해시코드값으로 사용함
  │  toString()  │ "클래스이름@참조값" 형식의 문자열을 반환
  │  notify()    │ 스레드(thread) 관련 메소드
  │  wait()      │ 스레드(thread) 관련 메소드
  └--------------┘
         ▲
         │
  ┌--------------┐
  │  Person      │ 서브 클래스
  │--------------│
  │  @Override   │
  │  equals()    │ 원하는 방식으로 오버라이드한다.
  │              │
  │  @Override   │
  │  toString()  │ 원하는 방식으로 오버라이드한다.
  └--------------┘